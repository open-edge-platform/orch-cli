// SPDX-FileCopyrightText: 2023-present Intel Corporation
//
// SPDX-License-Identifier: Apache-2.0

package loader

import (
	"context"
	b64 "encoding/base64"
	"fmt"
	"github.com/open-edge-platform/app-orch-catalog/pkg/schema/upload"
	"github.com/open-edge-platform/cli/pkg/auth"
	"os"

	restclient "github.com/open-edge-platform/cli/pkg/rest/catalog"
	"gopkg.in/yaml.v3"
)

const (
	schemaVersion = "0.1"
	permissions   = 0600
)

// Exporter implements the functions used to export YAML files
type Exporter struct {
	output []string
}

// LogChange prints the given formatted output to stdout if the verbose flag is enabled
func (e *Exporter) LogChange(format string, a ...any) {
	e.output = append(e.output, fmt.Sprintf(format, a...))
}

// GetOutput returns the output generated by the command
func (e *Exporter) GetOutput() []string {
	return e.output
}

// NewExporter returns an initialized loader
func NewExporter() *Exporter {
	return &Exporter{
		output: make([]string, 0),
	}
}

// ExportCatalogItems exports all items published (in the application catalog) by the specified project into the
// given directory as YAML files; one YAML file per item, e.g. registry, artifact, application, deployment package.
func (e *Exporter) ExportCatalogItems(ctx context.Context, restClient *restclient.ClientWithResponses, projectName string, exportDirPath string) error {
	e.LogChange("Exporting data for project %s to directory %s\n", projectName, exportDirPath)
	if err := e.exportRegistries(ctx, projectName, restClient, exportDirPath); err != nil {
		return err
	}
	if err := e.exportArtifacts(ctx, projectName, restClient, exportDirPath); err != nil {
		return err
	}
	if err := e.exportApplications(ctx, projectName, restClient, exportDirPath); err != nil {
		return err
	}
	return e.exportDeploymentPackages(ctx, projectName, restClient, exportDirPath)
}

func fileName(path string, baseName string) string {
	return fmt.Sprintf("%s/%s.yaml", path, baseName)
}

func saveSpec(spec *upload.YamlSpec) error {
	// Save the file name so that we can drop it from the output
	fileName := spec.FileName
	spec.FileName = ""

	// Marshal the spec into YAML and write the file
	data, err := yaml.Marshal(spec)
	if err != nil {
		return err
	}
	return os.WriteFile(fileName, data, permissions)
}

func (e *Exporter) exportRegistries(ctx context.Context, projectName string, client *restclient.ClientWithResponses, path string) error {
	resp, err := client.CatalogServiceListRegistriesWithResponse(ctx, projectName, &restclient.CatalogServiceListRegistriesParams{},
		auth.AddAuthHeader)
	if err != nil {
		return err
	}

	for _, reg := range resp.JSON200.Registries {
		e.LogChange("Exporting registry %s\n", reg.Name)
		spec := &upload.YamlSpec{
			FileName:      fileName(path, fmt.Sprintf("registry-%s", reg.Name)),
			SpecSchema:    upload.RegistryType,
			SchemaVersion: schemaVersion,
			Name:          reg.Name,
			DisplayName:   *reg.DisplayName,
			Description:   *reg.Description,
			RootURL:       reg.RootUrl,
			UserName:      *reg.Username,
			AuthToken:     *reg.AuthToken,
			CACerts:       *reg.Cacerts,
			Type:          reg.Type,
		}
		if err = saveSpec(spec); err != nil {
			return err
		}
	}
	return nil
}

func (e *Exporter) exportArtifacts(ctx context.Context, projectName string, client *restclient.ClientWithResponses, path string) error {
	resp, err := client.CatalogServiceListArtifactsWithResponse(ctx, projectName, &restclient.CatalogServiceListArtifactsParams{},
		auth.AddAuthHeader)
	if err != nil {
		return err
	}

	for _, art := range resp.JSON200.Artifacts {
		e.LogChange("Exporting artifact %s\n", art.Name)
		spec := &upload.YamlSpec{
			FileName:      fileName(path, fmt.Sprintf("artifact-%s", art.Name)),
			SpecSchema:    upload.ArtifactType,
			SchemaVersion: schemaVersion,
			Name:          art.Name,
			DisplayName:   *art.DisplayName,
			Description:   *art.Description,
			MimeType:      art.MimeType,
			Artifact:      b64.StdEncoding.EncodeToString(art.Artifact),
		}
		if err = saveSpec(spec); err != nil {
			return err
		}
	}
	return nil
}

func (e *Exporter) exportApplications(ctx context.Context, projectName string, client *restclient.ClientWithResponses, path string) error {
	resp, err := client.CatalogServiceListApplicationsWithResponse(ctx, projectName, &restclient.CatalogServiceListApplicationsParams{},
		auth.AddAuthHeader)
	if err != nil {
		return err
	}

	for _, app := range resp.JSON200.Applications {
		e.LogChange("Exporting application %s\n", app.Name)
		profiles, err := e.exportProfiles(path, app)
		ignoredResources := e.exportIgnoredResources(app)
		if err != nil {
			return err
		}
		spec := &upload.YamlSpec{
			FileName:         fileName(path, fmt.Sprintf("application-%s-%s", app.Name, app.Version)),
			SpecSchema:       upload.ApplicationType,
			SchemaVersion:    schemaVersion,
			Name:             app.Name,
			Version:          app.Version,
			DisplayName:      *app.DisplayName,
			Description:      *app.Description,
			HelmRegistry:     app.HelmRegistryName,
			ImageRegistry:    *app.ImageRegistryName,
			ChartName:        app.ChartName,
			ChartVersion:     app.ChartVersion,
			Profiles:         profiles,
			DefaultProfile:   *app.DefaultProfileName,
			IgnoredResources: ignoredResources,
		}
		if err = saveSpec(spec); err != nil {
			return err
		}
	}
	return nil
}

func (e *Exporter) exportProfiles(path string, app restclient.Application) ([]upload.Profile, error) {
	profiles := make([]upload.Profile, 0, len(*app.Profiles))
	for _, p := range *app.Profiles {
		fileName, err := e.exportProfile(path, app, p)
		if err != nil {
			return nil, err
		}
		profiles = append(profiles, upload.Profile{
			Name:                   p.Name,
			DisplayName:            *p.DisplayName,
			Description:            *p.Description,
			ValuesFileName:         fileName,
			DeploymentRequirements: e.exportDeploymentRequirements(p),
			ParameterTemplates:     e.exportParameterTemplates(p),
		})
	}
	return profiles, nil
}

func (e *Exporter) exportProfile(path string, app restclient.Application, p restclient.Profile) (string, error) {
	e.LogChange("Exporting profile %s\n", p.Name)
	baseFile := fmt.Sprintf("values-%s-%s-%s.yaml", app.Name, app.Version, p.Name)
	valuesFile := fmt.Sprintf("%s/%s", path, baseFile)
	if err := os.WriteFile(valuesFile, []byte(*p.ChartValues), permissions); err != nil {
		return "", err
	}
	return baseFile, nil
}

func (e *Exporter) exportIgnoredResources(app restclient.Application) []upload.ResourceReference {
	resources := make([]upload.ResourceReference, 0, len(*app.IgnoredResources))
	for _, r := range *app.IgnoredResources {
		namespace := ""
		if r.Namespace != nil {
			namespace = *r.Namespace
		}
		resources = append(resources, upload.ResourceReference{Name: r.Name, Kind: r.Kind, Namespace: namespace})
	}
	return resources
}

func (e *Exporter) exportDeploymentRequirements(p restclient.Profile) []upload.DeploymentRequirement {
	requirements := make([]upload.DeploymentRequirement, 0, len(*p.DeploymentRequirement))
	for _, dr := range requirements {
		requirements = append(requirements, upload.DeploymentRequirement{
			Publisher:         dr.Publisher,
			Name:              dr.Name,
			Version:           dr.Version,
			DeploymentProfile: dr.DeploymentProfile,
		})
	}
	return requirements
}

func (e *Exporter) exportParameterTemplates(p restclient.Profile) []upload.ParameterTemplate {
	templates := make([]upload.ParameterTemplate, 0, len(*p.ParameterTemplates))
	for _, pt := range templates {
		templates = append(templates, upload.ParameterTemplate{
			Name:            pt.Name,
			DisplayName:     pt.DisplayName,
			Type:            pt.Type,
			Default:         pt.Default,
			Validator:       pt.Validator,
			SuggestedValues: pt.SuggestedValues,
			Secret:          pt.Secret,
			Mandatory:       pt.Mandatory,
		})
	}
	return templates
}

func (e *Exporter) exportExtensions(exts []restclient.APIExtension) []upload.APIExtension {
	extensions := make([]upload.APIExtension, 0, len(exts))
	for _, ext := range exts {
		extensions = append(extensions, e.exportExtension(ext))
	}
	return extensions
}

func (e *Exporter) exportExtension(ext restclient.APIExtension) upload.APIExtension {
	extension := upload.APIExtension{
		Name:        ext.Name,
		Version:     ext.Version,
		DisplayName: *ext.DisplayName,
		Description: *ext.Description,
		Endpoints:   nil,
	}

	if ext.UiExtension != nil {
		extension.UIExtension = &upload.UIExtension{
			Label:       &ext.UiExtension.Label,
			ServiceName: ext.UiExtension.ServiceName,
			Description: ext.UiExtension.Description,
			FileName:    ext.UiExtension.FileName,
			AppName:     ext.UiExtension.AppName,
			ModuleName:  ext.UiExtension.ModuleName,
		}
	}

	if ext.Endpoints != nil {
		extension.Endpoints = make([]*upload.Endpoint, 0, len(*ext.Endpoints))
		for _, ep := range *ext.Endpoints {
			appName := ""
			if ep.AppName != nil {
				appName = *ep.AppName
			}
			extension.Endpoints = append(extension.Endpoints, &upload.Endpoint{
				ServiceName:  ep.ServiceName,
				ExternalPath: ep.ExternalPath,
				InternalPath: ep.InternalPath,
				Scheme:       ep.Scheme,
				AuthType:     ep.AuthType,
				AppName:      appName,
			})
		}
	}

	return extension
}

func (e *Exporter) exportDeploymentPackages(ctx context.Context, projectName string, client *restclient.ClientWithResponses, path string) error {
	resp, err := client.CatalogServiceListDeploymentPackagesWithResponse(ctx, projectName, &restclient.CatalogServiceListDeploymentPackagesParams{},
		auth.AddAuthHeader)
	if err != nil {
		return err
	}

	for _, pkg := range resp.JSON200.DeploymentPackages {
		e.LogChange("Exporting deployment package %s\n", pkg.Name)
		spec := &upload.YamlSpec{
			FileName:                   fileName(path, fmt.Sprintf("deployment-package-%s-%s", pkg.Name, pkg.Version)),
			SpecSchema:                 upload.DeploymentPackageType,
			SchemaVersion:              schemaVersion,
			Name:                       pkg.Name,
			Version:                    pkg.Version,
			DisplayName:                *pkg.DisplayName,
			Description:                *pkg.Description,
			Applications:               e.exportApplicationReferences(pkg),
			ApplicationDependencies:    e.exportApplicationDependencies(pkg),
			DeploymentProfiles:         e.exportDeploymentProfiles(pkg),
			DefaultProfile:             *pkg.DefaultProfileName,
			IsDeployed:                 *pkg.IsDeployed,
			IsVisible:                  *pkg.IsVisible,
			ForbidsMultipleDeployments: *pkg.ForbidsMultipleDeployments,
			Extensions:                 e.exportExtensions(pkg.Extensions),
			DefaultNamespaces:          e.exportDefaultNamespaces(pkg.DefaultNamespaces),
			Namespaces:                 e.exportNamespaces(pkg.Namespaces),
		}
		if err = saveSpec(spec); err != nil {
			return err
		}
	}
	return nil
}

func (e *Exporter) exportDeploymentProfiles(app restclient.DeploymentPackage) []upload.DeploymentProfile {
	profiles := make([]upload.DeploymentProfile, 0, len(*app.Profiles))
	for _, p := range *app.Profiles {
		appProfiles := make([]upload.ApplicationProfile, 0, len(*app.Profiles))
		for appName, profileName := range p.ApplicationProfiles {
			appProfiles = append(appProfiles, upload.ApplicationProfile{ApplicationName: appName, ProfileName: profileName})
		}
		profiles = append(profiles, upload.DeploymentProfile{
			Name:                p.Name,
			DisplayName:         *p.DisplayName,
			Description:         *p.Description,
			ApplicationProfiles: appProfiles,
		})
	}
	return profiles
}

func (e *Exporter) exportApplicationReferences(pkg restclient.DeploymentPackage) []upload.Application {
	apprefs := make([]upload.Application, 0, len(pkg.ApplicationReferences))
	for _, ref := range pkg.ApplicationReferences {
		apprefs = append(apprefs, upload.Application{
			Name:    ref.Name,
			Version: ref.Version,
		})
	}
	return apprefs
}

func (e *Exporter) exportApplicationDependencies(pkg restclient.DeploymentPackage) []upload.ApplicationDependency {
	appdeps := make([]upload.ApplicationDependency, 0, len(*pkg.ApplicationDependencies))
	for _, dep := range *pkg.ApplicationDependencies {
		appdeps = append(appdeps, upload.ApplicationDependency{
			Name:     dep.Name,
			Requires: dep.Requires,
		})
	}
	return appdeps
}

func (e *Exporter) exportDefaultNamespaces(namespaces *map[string]string) map[string]string {
	if namespaces == nil {
		return map[string]string{}
	}
	return *namespaces
}

func (e *Exporter) exportNamespaces(namespaces *[]restclient.Namespace) []upload.Namespace {
	list := make([]upload.Namespace, 0)
	if namespaces != nil {
		for _, ns := range *namespaces {
			item := upload.Namespace{Name: ns.Name}
			if ns.Labels != nil {
				item.Labels = *ns.Labels
			}
			if ns.Annotations != nil {
				item.Annotations = *ns.Annotations
			}
			list = append(list, item)
		}
	}
	return list
}
